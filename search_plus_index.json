{"./":{"url":"./","title":"介绍","keywords":"","body":"本电子书的介绍 Python & C++ 联合编程 本书为本人学习笔记，并非专门的学习教程，有不严谨之处请见谅。 持续更新之中。 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_1.html":{"url":"chapter2/2_1.html","title":"print输出格式设定","keywords":"","body":"print函数的使用 print输出，写入文件 python的print不仅能输出字符串、整数，还能将对象作为字符串输出，甚至可以写入文件 print(value,...,sep=' ',end='\\n',file=sys.stdout,flush=False) sep: 分隔符，默认空格 end: 结尾处，默认换行,所以每次打印会默认换行 file: 输出文件，默认标准输出（stderr,错误输出） flush: 刷新。为提高效率，写到标准输出、错误输出、文件都会有缓冲区，不会立刻写入硬盘。flush值改为true可以实时地将缓冲区的内容输出 python中可以通过参数的名称来传递参数，这样不用考虑参数的顺序 print函数使用示例 print('str1','str2','str3') print(sys) logf = open(\"log.txt\",\"a\") #a表示用追加的方式,默认为只读打开 print(\"Log to file\",file = logf) #将\"Log to file\"以追加方式写入logf文件 logf.close() # 注意对于文件，再结束的时候要将其关闭，释放资源。因为文件句柄是有限的。 # 文件关闭时会将缓冲区内容全部写入 注意：用print同时使用stdout和stderr进行输出时，二者的输出顺序未必和代码顺序相同，因为stdout和stderr使用的是两个不同的缓冲区 print输出到文件并输出csv格式的excel表格 写入excel的csv格式文件 csv = open(\"python.csv\",\"a\") #csv文件可用excel打开 print(\"名称\",\"数量\",\"内容\",sep=\",\",file=csv) print(\"name1\",\"1\",\"111\",sep=\",\",file=csv) print(\"name2\",\"2\",\"222\",sep=\",\",file=csv) print(\"name3\",\"3\",\"333\",sep=\",\",file=csv) csv.close() © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-20 "},"chapter2/2_2.html":{"url":"chapter2/2_2.html","title":"注释、分号和换行","keywords":"","body":"注释、分号和换行 单行注释 # 单行注释 \"\"\"多行注释\"\"\" python默认以换行行为为语句结束 ;用于同一行语句分割（尽量不用） \\反斜杠拼接多行语句# 一行内写多条语句 print(\"test\");print(test) © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-20 "},"chapter2/2_3.html":{"url":"chapter2/2_3.html","title":"Python基本数据类型","keywords":"","body":"Python基本数据类型 python的所有类型都类型C++中的引用，它内部通过引用计数进行来进行垃圾回收 Number String bytes 基础数据类型，不可变 List(列表) Dictionary(字典) 容器类型，可修改 Tuple(元组) 不可修改 基本数据类型 python3中的基本数据类型有int float bool complex #int num = 1 print(num) # output: 1 print(type(num))# print(id(num)) # 1686331552 num = 1.0 print(num) # 1.0 print(type(num)) # print(id(num)) # 1686331552 上面代码中的num前后指向两块不同的内存空间,前面的一块空间再num = 1.0后被释放 python内部机制 python类型的内部机制可以参考下面3篇博文 Python内部机制-PyObject对象 Python内部机制-PyTypeObject对象 Python内部机制-PyIntObject对象 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-20 "},"chapter2/2_4.html":{"url":"chapter2/2_4.html","title":"Python字符集问题","keywords":"","body":"Python字符集问题 本节介绍python的string的用法。string内部是用unsigned int来存储字符串。 Py_UCS4 unsigned int 所以python的字符串的存储空间是比较大的，现在python中的字符串统一使用utf来存储 与python有关的字符集 python源码字符集 ：utf 用ASCII码编译python可能会报错. ASCII字符集 GBK(2个ASCII码来存储一个汉字) GB2312 GBK和GB2312还是用ASCII码来存储其他文字 UTF-8 UTF-16 UTF-32(UCS4) python注重简洁，所以内部全部使用UTF-32来存储 总结：python的源码用的是utf-8，但是其内部的存储用的是utf-32 Python字符串操作 访问 str1 = \"测试字符串001\" print(str1) print(id(str1)) # 输出 2115250249600 str1 = \"测试字符串002\" print(id(str1)) # 输出 2115250898064 由于python采用utf-32存储，所以不管是汉字还是英文数字等，在用下标进行访问时占位都只占1位 print(str1[2]) // 输出 \"字\" print(str1[5]) // 输出 \"0\" 切片 下面的访问方式是python中特有的 # 3为开始位置，5为结束位置尾后位置 print(str1[3:5]) # 输出 \"符串\" # 负数从结尾开始 print(str1[-3:-1]) # 00 #从倒数第3个取到第1个 print(str1[:-2]) # 测试字符串0 字符串转义 如果一个字符串里面有很多转义，只用在字符串开始加一个r或R，转义为普通字符串 print(r\"dd\\tdd\\t\") # 输出 dd\\tdd\\t 字符串拼接 多行字符串拼接的3种方式 a = \"111\" \\ \"222\" \\ \"333\" print(a) # 输出111222333 a = \"111 \\ 222 \\ 333\" print(a) # 输出111 222 333 a = \"\"\" aaa bbb ccc \"\"\" print(a) \"\"\" 输出 aaa bbb ccc \"\"\" 字符串的拼接还可以直接对两个字符串使用+运算符:s1+s2 注意如果s1和s2较大，拼接操作会有较大时间开销，应为python相当于执行拷贝操作新生成一个字符串对象 对整型进行拼接 str(123)+str(100.9) 格式化字符串 %s 字符串 %d 整数 %c 字符 python里面没有char类型，可以通过chr()进行转化 %f 浮点数s4 = \"格式化字符串 %s %d %c %f\" % (\"test\",300,chr(66), 10.9 ) print(s4) # 输出 格式化字符串 test 300 B 10.900000 字符串长度 注意字符串不是内部存储的长度，而是整个的字数（汉字和英文都是记为1个数） © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_5.html":{"url":"chapter2/2_5.html","title":"容器类型","keywords":"","body":"list(列表) list本身是可更改的,list里面的元素可以是任意类型。相当于C++里面用list存放指针，指针指向不同的变量 C++里面list的存储方式是链表 python里面list的存储方式是线性表，即一块连续的空间来存储数据。删除O(n)，修改访问O(1). 线性表的缺点是：插入会移动整个表，新增和删除会realloc存储空间。对于大列表的新增和删除操作，可以调用C接口实现以提高效率 list的基本用法参见手册 tuple(元组) tuple指向不可更改，（但是值可以变，例如元组中有一个list元素） # 创建元组 # 函数参数的传递也相当于传递元组 t1 = (\"v1\",\"v2\",3) dictionary(字典) 字典定义格式如下 {\"key1\":value1,\"key2\":value2} 注意value相当于容器，可以是任意类型，而key需要计算hash，所以只能是string或Number dic = {\"name\":\"python\", \"year\":1991, \"ver\":3.7, 4:5, \"keys\":[\"print\",\"for\"]} # 新增和更改 dic[4] = 6 dic[\"src\"] = \"C\" # 删除 del dic[4] # 删除下标4 dic.clear() # 整表删除 # 判断关键字 dic[\"arg\"] # 由于没有arg关键字，会抛出KeyError异常 我们可以捕获上述代码的KeyError异常 try: print(dic[\"arg\"]) except KeyError: print(\"dic KeyError\") 也可以使用if语句来判断关键字是否在字典里 if \"year\" in dic: print(\"key year in dic\") else: print(\"key year not in dic\") © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_6.html":{"url":"chapter2/2_6.html","title":"控制流","keywords":"","body":"if语句 python比较运算符 == 等于 ！= 或者 <> 不等于 逻辑运算符 and、or、not 成员运算符 in、not in 身份运算符 is、is notlist1 = [1,2,3,4,5] if 1 in list1: print(\"1 in list\") if 8 not in list1: print(\"8 not in list) 身份运算符用于确定两个变量是否是同一个变量，python里面的变量存的并不是实际的值，而是一个地址。两个变量指向同一个地址则说明两个变量是一致的(其实就等同于判断id(a)和id(b)是否相同) 在python里为了节省空间可能会将一些小的整型进行缓存，此时两个变量的地址是一致的，如下面的示例代码 a = 100 b = 100 if a is b: print(\"a is b\") # if语句执行 while语句 python中的while与C语言的区别在于：python中的while还可以使用else，当while条件不满足时还会执行一次else中的语句。但要注意使用break跳出循环后不会再执行else语句。 for语句 注意下面的用法 for i in range(10) for i in range(5, 10 ,2) list1 = [1, 2, 3, 4, 5, 6] # 打印 1 2 3 4 5 6 end i = 6 for i in list1: print(i, end = \" \") else: print(\"end i = \", i) # 打印 0,1,2,3,4,5,6,7,8,9, for i in range(10): print(i, end = \",\") # 打印 10,20,30,40,50,60,70,80,90, for i in range(10, 100, 10): print(i, end = \",\") 不要用python的for循环来做大批量数据的处理，这样效率非常低 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-20 "},"chapter2/2_7.html":{"url":"chapter2/2_7.html","title":"函数","keywords":"","body":"python函数 函数的参数 函数定义方法 def 函数名(参数列表): 函数体 函数的参数有必选参数和默认参数，默认参数可以不传，但是默认参数后面不能有必选参数 可变参数 fun(fmt,*args) 没有关键字参数时，可变参数要放在最后面 关键字参数print(fmt, args, *kw) 关键字参数要放在最后面 可变参数示例 def fun(fmt, *values): print(fmt) # 打印 values type is # 说明可变参数传递的是元组 print(\"values type is\",type(values)) print(values) # 打印 (1, 2) for v in values: print(\"v = \", v) fun(\"%d\", 1, 2) 关键字参数示例 # 关键字参数 def fun4(a, **kw): print(\"a = \", a) # a = 100 print(\"kw type is \", type(kw)) # kw type is if \"name\" in kw: print(kw[\"name\"]) # xiaoming fun4(100, name = \"xiaoming\") python函数返回值 返回的方式 return或者没有return语句 return None None表示没有，与C语言不同，python中对None的访问会出错 return re 返回1个值 return r1,r2,r3 返回多个值 python函数return之后内部参数的引用计数会加1， 注意，python中没有局部变量的概念，都是引用，变量出了作用域引用计数会减1 return语句将参数引用计数加1，出了函数后参数引用计数减1,所以python中函数里的局部变量在函数外也可以访问 下面的代码说明return默认返回None def fun1(): print(\"fun1\") re = fun1() print(re) # 打印 None 下面的代码示例返回多个值 def fun4(): return 5, \"test\", [1, 2] i, s, l = fun4() print(\"i is \", i) # 5 print(\"s is \", s) # test print(\"l is \", l) # [1,2] 闭包(Closure) 闭包本质就是内嵌函数 先看一个简单的闭包示例 def outfun(a): def infun(b): return a + b return infun f = outfun(1) print(\"f() = \", f(3)) # 打印4 闭包返回了一个函数， lambda函数 lambda语法 lambda [parameters]:expression 例如lambda x,y:x*y;函数输入是x和y，输出是他们的积 lambda使用示例 fun = lambda x, y : x*y print(\"lambda fun = \",fun(3,5)) # lambda fun = 15 def testfun(): return lambda x,y:x+y f = testfun() print(f(1,2)) # 3 函数中变量的作用域 python中变量的作用域有两种 Local(函数内部)局部作用域 Enclosing(嵌套函数的外层函数内部) 嵌套作用域（闭包） Global（模块全局）全局作用域 Built-in(内建)内建作用域 上述作用域的优先级从上往下依次减小L->E->G->B，（即变量查找次序从上往下） 那么,如果我们在Local作用域但是想要访问E作用域的变量，要怎么做？可以使用global和nonlocal关键字。 global：函数内访问全局变量 # 全局作用域 gx = 1001 def fun(): global gx # 用global来使用全局的gx变量 gx += 1000 print(gx) fun() # 2001 nonlocal:闭包函数访问外部函数变量 def fun(): c = 1002 def infun(): # 内嵌作用域 nonlocal c print(c) return infun f = fun() f() # 输出1002 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_8.html":{"url":"chapter2/2_8.html","title":"面向对象","keywords":"","body":"类和实例 类就是给python自定义的一种类型，实例就是这个类型的一个对象，要在内存中占有空间。 类的语法 class 类名（父类）: __name = \"test\" #私有成员变量 age = 20 #成员变量 def __init__(self): #构造函数 print(self.__name) def func(self): #成员函数 print(self.age) 类的继承 class Video(object): def __init__(self,path): pass class Mp4Video(Video): def __init__(self): Video.__init__(self,\"d:\\\\test.mp4\") print(\"Mp4Video\",self.name) v1 = Mp4Video() print(dir(Mp4Video)) # dir()函数可以打印所传类中的所有成员 类的创建实例 class Video(object): #构造函数 def __init__(self): print(\"Create Video\") def __del__(self): print(\"Delete Video\") video = Video() # 打印 Create Video print(Video) # 打印 \"\" print(video) # 打印 \"\" print(dir(video)) print(\"end\") # 析构函数在整个程序退出后执行 # \"Delete Video\"在\"end\"之后打印 上述代码print(Video)打印出“”,__main__为模块名，python中每个文件就是一个模块，多个文件需要有一个入口文件，即从哪一个模块开始执行，__main__模块相当于C++中的main函数。 类的成员 类的成员创建有多种方法 1 直接通过对象创建成员变量 video.title = \"test\" # 创建一个title成员 print(\"title=\",video.title) # test 2 在构造函数中通过self创建成员变量 class Video(object): def __init__(self): self.name = \"Video name\" video = Video() print(video.name) 3 上面的方式都是隐式地生成成员变量，还可以直接声明成员变量 class Video(object): # 声明成员变量 age = 20 # 构造函数 析构函数代码 # 4 声明私有成员变量只需要在成员变量名前面添加__ class Video(object): # 私有成员变量 __name = \"private name\" # 构造函数 析构函数代码 # def getName(self): return self.__name video = Video() print(video.__name) # 抛出错误，私有成员变量无法访问 print(video.getName()) # 私有成员的正确访问方法 类的继承 我们创建一个Mp4Video类继承上面的Video类，继承会获得父类的所有成员变量和方法 class Mp4Video(Video): def __init__(self): print(\"Create Mp4Video\") mp4 = Mp4Video() 注意：与C++不同，python中在生成子类对象的时候不会去自动调用其父类的构造函数,只会调用子类构造函数。 可用如下方法显示调用父类构造函数 class Mp4Video(Video): def __init__(self): Video.__init__(self) print(\"Create Mp4Video\") mp4 = Mp4Video() print(isinstance(mp4,Mp4Video)) # 打印True print(isinstance(mp4,Video)) # 打印True 同样的，如果子类中也定义了析构函数，Python也只会调用子类的析构函数。若子类没有定义析构函数，则会去调用父类的构造函数 技巧：当有多个继承类，要通过类型来选择时，可以通过isinstance来判断，利用这样的动态代码，来使我们的设计模式更加便捷 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_9.html":{"url":"chapter2/2_9.html","title":"模块和包","keywords":"","body":"module(模块) python的每个文件就是一个模块 导入模块，可以是py源码也可以是pyd库。引入模块语句如下 import module1[,module2[,...moduleN]] REF:py、pyc、pyo、pyd文件区别 模块导入指定的部分到当前的命名空间,或从一个包里面导入某一个模块 from modname import name1[,name2[,...nameN]] 其中第一种导入方式在使用模块内的函数时需要写出modname.funcname，第二种导入方式直接写函数名或变量名，不需要在前面加模块名 导入模块代码 import packet.mod1 import packet.dir1.mod1 from mod1 import * packet(包) 一个包含一个__init__.py文件的目录,import时会调用一次进行初始化。 __all__ from pack import *并不会导入所有模块，而是会将__all__变量里的模块全部导入，所以我们可以在__init__.py文件中配置__all__变量 __all__ = [\"video\",\"audio\"] __name__ python中的模块就是一个普通文件，不像C++里面有lib、dll的调用。这个文件可能被直接调用，为了判断代码是被模块加载还是直接执行的主模块，可以使用__name__来获取当前模块名称 if __name__ == '__main__' 模块的导入路径 python是如何寻找导入模块的目录呢？ 在python中提供了sys模块，sys.path列表提供了查找模块的路径。如果一个库在多个目录中都有，会按列表的次序来查找。如果我们想自己建一个目录，让python来这个目录查找模块，可以用如下方式 sys.path.insert(0,\"../\") 0表示插入位置，../当前路径的上一层路径。 包的导入 如果我们有一个mypack包，包里面有audio、video和opengl三个模块, # 需要加上包和模块的名称 import mypack.video mypack.video.view() # 引入包的命名空间,不用加包名称 from mypack import audio audio.play() # 引入包和模块的命名空间 from mypack.audio import play play() # 不导入mypack包里的所有模块，只导入__init__.py文件里所有的函数和成员 from mypack import * mypack.opengl.draw() # 调入失败，模块未导入 为了使from mypack import *能导入opengl,__init__.py文件可编写如下 __init__.py __all__ = [\"audio\",\"video\",\"opengl\"] def init(): print(\"mapack init function\") 包里面还可以包含子包，这里不再赘述 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_10.html":{"url":"chapter2/2_10.html","title":"多进程","keywords":"","body":"python多进程编程 python多进程编程有多种方式 os.fork() linux unix mac 多个进程使用同一段代码(返回0为子进程，非0为父进程) Process() 跨平台 运行多次虚拟机 os.system() © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "}}