{"./":{"url":"./","title":"介绍","keywords":"","body":"本电子书的介绍 Python & C++ 联合编程 本书为本人学习笔记，并非专门的学习教程，有不严谨之处请见谅。 持续更新之中。 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_1.html":{"url":"chapter2/2_1.html","title":"print输出格式设定","keywords":"","body":"print函数的使用 print输出，写入文件 python的print不仅能输出字符串、整数，还能将对象作为字符串输出，甚至可以写入文件 print(value,...,sep=' ',end='\\n',file=sys.stdout,flush=False) sep: 分隔符，默认空格 end: 结尾处，默认换行,所以每次打印会默认换行 file: 输出文件，默认标准输出（stderr,错误输出） flush: 刷新。为提高效率，写到标准输出、错误输出、文件都会有缓冲区，不会立刻写入硬盘。flush值改为true可以实时地将缓冲区的内容输出 python中可以通过参数的名称来传递参数，这样不用考虑参数的顺序 print函数使用示例 print('str1','str2','str3') print(sys) logf = open(\"log.txt\",\"a\") #a表示用追加的方式,默认为只读打开 print(\"Log to file\",file = logf) #将\"Log to file\"以追加方式写入logf文件 logf.close() # 注意对于文件，在结束的时候要将其关闭，释放资源。因为文件句柄是有限的。 # 文件关闭时会将缓冲区内容全部写入 注意：用print同时使用stdout和stderr进行输出时，二者的输出顺序未必和代码顺序相同，因为stdout和stderr使用的是两个不同的缓冲区 print输出到文件并输出csv格式的excel表格 写入excel的csv格式文件 csv = open(\"python.csv\",\"a\") #csv文件可用excel打开 print(\"名称\",\"数量\",\"内容\",sep=\",\",file=csv) print(\"name1\",\"1\",\"111\",sep=\",\",file=csv) print(\"name2\",\"2\",\"222\",sep=\",\",file=csv) print(\"name3\",\"3\",\"333\",sep=\",\",file=csv) csv.close() © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-06-03 "},"chapter2/2_2.html":{"url":"chapter2/2_2.html","title":"注释、分号和换行","keywords":"","body":"注释、分号和换行 单行注释 # 单行注释 \"\"\"多行注释\"\"\" python默认以换行行为为语句结束 ;用于同一行语句分割（尽量不用） \\反斜杠拼接多行语句# 一行内写多条语句 print(\"test\");print(test) © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-20 "},"chapter2/2_3.html":{"url":"chapter2/2_3.html","title":"Python基本数据类型","keywords":"","body":"Python基本数据类型 python的所有类型都类似C++中的引用，它内部通过引用计数进行来进行垃圾回收 Number String bytes 基础数据类型，不可变 List(列表) Dictionary(字典) 容器类型，可修改 Tuple(元组) 容器类型，不可修改 基本数据类型 python3中的基本数据类型有int float bool complex #int num = 1 print(num) # output: 1 print(type(num))# print(id(num)) # 1686331552 num = 1.0 print(num) # 1.0 print(type(num)) # print(id(num)) # 1686331552 上面代码中的num前后指向两块不同的内存空间,前面的一块空间在num = 1.0后被释放 python内部机制 python类型的内部机制可以参考下面3篇博文 Python内部机制-PyObject对象 Python内部机制-PyTypeObject对象 Python内部机制-PyIntObject对象 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-06-03 "},"chapter2/2_4.html":{"url":"chapter2/2_4.html","title":"Python字符集问题","keywords":"","body":"Python字符集问题 本节介绍python的string的用法。string内部是用unsigned int来存储字符串。 Py_UCS4 unsigned int 所以python的字符串的存储空间是比较大的，现在python中的字符串统一使用utf来存储 与python有关的字符集 python源码字符集 ：utf 用ASCII码编译python可能会报错. ASCII字符集 GBK(2个ASCII码来存储一个汉字) GB2312 GBK和GB2312还是用ASCII码来存储其他文字 UTF-8 UTF-16 UTF-32(UCS4) python注重简洁，所以内部全部使用UTF-32来存储 总结：python的源码用的是utf-8，但是其内部的存储用的是utf-32 Python字符串操作 访问 str1 = \"测试字符串001\" print(str1) print(id(str1)) # 输出 2115250249600 str1 = \"测试字符串002\" print(id(str1)) # 输出 2115250898064 由于python采用utf-32存储，所以不管是汉字还是英文数字等，在用下标进行访问时占位都只占1位 print(str1[2]) // 输出 \"字\" print(str1[5]) // 输出 \"0\" 切片 下面的访问方式是python中特有的 # 3为开始位置，5为结束位置尾后位置 print(str1[3:5]) # 输出 \"符串\" # 负数从结尾开始 print(str1[-3:-1]) # 00 #从倒数第3个取到第1个 print(str1[:-2]) # 测试字符串0 字符串转义 如果一个字符串里面有很多转义，只用在字符串开始加一个r或R，转义为普通字符串 print(r\"dd\\tdd\\t\") # 输出 dd\\tdd\\t 字符串拼接 多行字符串拼接的3种方式 a = \"111\" \\ \"222\" \\ \"333\" print(a) # 输出111222333 a = \"111 \\ 222 \\ 333\" print(a) # 输出111 222 333 a = \"\"\" aaa bbb ccc \"\"\" print(a) \"\"\" 输出 aaa bbb ccc \"\"\" 字符串的拼接还可以直接对两个字符串使用+运算符:s1+s2 注意如果s1和s2较大，拼接操作会有较大时间开销，因为python相当于执行拷贝操作新生成一个字符串对象 对整型进行拼接 str(123)+str(100.9) 格式化字符串 %s 字符串 %d 整数 %c 字符 python里面没有char类型，可以通过chr()进行转化 %f 浮点数s4 = \"格式化字符串 %s %d %c %f\" % (\"test\",300,chr(66), 10.9 ) print(s4) # 输出 格式化字符串 test 300 B 10.900000 字符串长度 注意字符串不是内部存储的长度，而是整个的字数（汉字和英文都是记为1个数） © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-06-04 "},"chapter2/2_5.html":{"url":"chapter2/2_5.html","title":"容器类型","keywords":"","body":"list(列表) list本身是可更改的,list里面的元素可以是任意类型。相当于C++里面用list存放指针，指针指向不同的变量 C++里面list的存储方式是链表 python里面list的存储方式是线性表，即一块连续的空间来存储数据。删除O(n)，修改访问O(1). 线性表的缺点是：插入会移动整个表，新增和删除会realloc存储空间。对于大列表的新增和删除操作，可以调用C接口实现以提高效率 list的基本用法参见手册 tuple(元组) tuple指向不可更改，（但是值可以变，例如元组中有一个list元素） # 创建元组 # 函数参数的传递也相当于传递元组 t1 = (\"v1\",\"v2\",3) dictionary(字典) 字典定义格式如下 {\"key1\":value1,\"key2\":value2} 注意value相当于容器，可以是任意类型，而key需要计算hash，所以只能是string或Number dic = {\"name\":\"python\", \"year\":1991, \"ver\":3.7, 4:5, \"keys\":[\"print\",\"for\"]} # 新增和更改 dic[4] = 6 dic[\"src\"] = \"C\" # 删除 del dic[4] # 删除下标4 dic.clear() # 整表删除 # 判断关键字 dic[\"arg\"] # 由于没有arg关键字，会抛出KeyError异常 我们可以捕获上述代码的KeyError异常 try: print(dic[\"arg\"]) except KeyError: print(\"dic KeyError\") 也可以使用if语句来判断关键字是否在字典里 if \"year\" in dic: print(\"key year in dic\") else: print(\"key year not in dic\") © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_6.html":{"url":"chapter2/2_6.html","title":"控制流","keywords":"","body":"if语句 python比较运算符 == 等于 ！= 或者 <> 不等于 逻辑运算符 and、or、not 成员运算符 in、not in 身份运算符 is、is notlist1 = [1,2,3,4,5] if 1 in list1: print(\"1 in list\") if 8 not in list1: print(\"8 not in list) 身份运算符用于确定两个变量是否是同一个变量，python里面的变量存的并不是实际的值，而是一个地址。两个变量指向同一个地址则说明两个变量是一致的(其实就等同于判断id(a)和id(b)是否相同) 在python里为了节省空间可能会将一些小的整型进行缓存，此时两个变量的地址是一致的，如下面的示例代码 a = 100 b = 100 if a is b: print(\"a is b\") # if语句执行 while语句 python中的while与C语言的区别在于：python中的while还可以使用else，当while条件不满足时还会执行一次else中的语句。但要注意使用break跳出循环后不会再执行else语句。 for语句 注意下面的用法 for i in range(10) for i in range(5, 10 ,2) list1 = [1, 2, 3, 4, 5, 6] # 打印 1 2 3 4 5 6 end i = 6 for i in list1: print(i, end = \" \") else: print(\"end i = \", i) # 打印 0,1,2,3,4,5,6,7,8,9, for i in range(10): print(i, end = \",\") # 打印 10,20,30,40,50,60,70,80,90, for i in range(10, 100, 10): print(i, end = \",\") 不要用python的for循环来做大批量数据的处理，这样效率非常低 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-20 "},"chapter2/2_7.html":{"url":"chapter2/2_7.html","title":"函数","keywords":"","body":"python函数 函数的参数 函数定义方法 def 函数名(参数列表): 函数体 函数的参数有必选参数和默认参数，默认参数可以不传，但是默认参数后面不能有必选参数 可变参数 fun(fmt,*args) 没有关键字参数时，可变参数要放在最后面 关键字参数print(fmt, *args, **kw) 关键字参数要放在最后面 可变参数示例 def fun(fmt, *values): print(fmt) # 打印 values type is # 说明可变参数传递的是元组 print(\"values type is\",type(values)) print(values) # 打印 (1, 2) for v in values: print(\"v = \", v) fun(\"%d\", 1, 2) 关键字参数示例 # 关键字参数 def fun4(a, **kw): print(\"a = \", a) # a = 100 print(\"kw type is \", type(kw)) # kw type is if \"name\" in kw: print(kw[\"name\"]) # xiaoming fun4(100, name = \"xiaoming\") python函数返回值 返回的方式 return或者没有return语句 return None None表示没有，与C语言不同，python中对None的访问会出错 return re 返回1个值 return r1,r2,r3 返回多个值 python函数return之后内部参数的引用计数会加1， 注意，python中没有局部变量的概念，都是引用，变量出了作用域引用计数会减1 return语句将参数引用计数加1，出了函数后参数引用计数减1,所以python中函数里的局部变量在函数外也可以访问 下面的代码说明return默认返回None def fun1(): print(\"fun1\") re = fun1() print(re) # 打印 None 下面的代码示例返回多个值 def fun4(): return 5, \"test\", [1, 2] i, s, l = fun4() print(\"i is \", i) # 5 print(\"s is \", s) # test print(\"l is \", l) # [1,2] 闭包(Closure) 闭包本质就是内嵌函数 先看一个简单的闭包示例 def outfun(a): def infun(b): return a + b return infun f = outfun(1) print(\"f() = \", f(3)) # 打印4 闭包返回了一个函数， lambda函数 lambda语法 lambda [parameters]:expression 例如lambda x,y:x*y;函数输入是x和y，输出是他们的积 lambda使用示例 fun = lambda x, y : x*y print(\"lambda fun = \",fun(3,5)) # lambda fun = 15 def testfun(): return lambda x,y:x+y f = testfun() print(f(1,2)) # 3 函数中变量的作用域 python中变量的作用域有两种 Local(函数内部)局部作用域 Enclosing(嵌套函数的外层函数内部) 嵌套作用域（闭包） Global（模块全局）全局作用域 Built-in(内建)内建作用域 上述作用域的优先级从上往下依次减小L->E->G->B，（即变量查找次序从上往下） 那么,如果我们在Local作用域但是想要访问E作用域的变量，要怎么做？可以使用global和nonlocal关键字。 global：函数内访问全局变量 # 全局作用域 gx = 1001 def fun(): global gx # 用global来使用全局的gx变量 gx += 1000 print(gx) fun() # 2001 nonlocal:闭包函数访问外部函数变量 def fun(): c = 1002 def infun(): # 内嵌作用域 nonlocal c print(c) return infun f = fun() f() # 输出1002 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-06-04 "},"chapter2/2_8.html":{"url":"chapter2/2_8.html","title":"面向对象","keywords":"","body":"类和实例 类就是给python自定义的一种类型，实例就是这个类型的一个对象，要在内存中占有空间。 类的语法 class 类名（父类）: __name = \"test\" #私有成员变量 age = 20 #成员变量 def __init__(self): #构造函数 print(self.__name) def func(self): #成员函数 print(self.age) 类的继承 class Video(object): def __init__(self,path): pass class Mp4Video(Video): def __init__(self): Video.__init__(self,\"d:\\\\test.mp4\") print(\"Mp4Video\",self.name) v1 = Mp4Video() print(dir(Mp4Video)) # dir()函数可以打印所传类中的所有成员 类的创建实例 class Video(object): #构造函数 def __init__(self): print(\"Create Video\") def __del__(self): print(\"Delete Video\") video = Video() # 打印 Create Video print(Video) # 打印 \"\" print(video) # 打印 \"\" print(dir(video)) print(\"end\") # 析构函数在整个程序退出后执行 # \"Delete Video\"在\"end\"之后打印 上述代码print(Video)打印出“”,__main__为模块名，python中每个文件就是一个模块，多个文件需要有一个入口文件，即从哪一个模块开始执行，__main__模块相当于C++中的main函数。 类的成员 类的成员创建有多种方法 1 直接通过对象创建成员变量 video.title = \"test\" # 创建一个title成员 print(\"title=\",video.title) # test 2 在构造函数中通过self创建成员变量 class Video(object): def __init__(self): self.name = \"Video name\" video = Video() print(video.name) 3 上面的方式都是隐式地生成成员变量，还可以直接声明成员变量 class Video(object): # 声明成员变量 age = 20 # 构造函数 析构函数代码 # 4 声明私有成员变量只需要在成员变量名前面添加__ class Video(object): # 私有成员变量 __name = \"private name\" # 构造函数 析构函数代码 # def getName(self): return self.__name video = Video() print(video.__name) # 抛出错误，私有成员变量无法访问 print(video.getName()) # 私有成员的正确访问方法 类的继承 我们创建一个Mp4Video类继承上面的Video类，继承会获得父类的所有成员变量和方法 class Mp4Video(Video): def __init__(self): print(\"Create Mp4Video\") mp4 = Mp4Video() 注意：与C++不同，python中在生成子类对象的时候不会去自动调用其父类的构造函数,只会调用子类构造函数。 可用如下方法显示调用父类构造函数 class Mp4Video(Video): def __init__(self): Video.__init__(self) print(\"Create Mp4Video\") mp4 = Mp4Video() print(isinstance(mp4,Mp4Video)) # 打印True print(isinstance(mp4,Video)) # 打印True 同样的，如果子类中也定义了析构函数，Python也只会调用子类的析构函数。若子类没有定义析构函数，则会去调用父类的构造函数 技巧：当有多个继承类，要通过类型来选择时，可以通过isinstance来判断，利用这样的动态代码，来使我们的设计模式更加便捷 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_9.html":{"url":"chapter2/2_9.html","title":"模块和包","keywords":"","body":"module(模块) python的每个文件就是一个模块 导入模块，可以是py源码也可以是pyd库。引入模块语句如下 import module1[,module2[,...moduleN]] REF:py、pyc、pyo、pyd文件区别 模块导入指定的部分到当前的命名空间,或从一个包里面导入某一个模块 from modname import name1[,name2[,...nameN]] 其中第一种导入方式在使用模块内的函数时需要写出modname.funcname，第二种导入方式直接写函数名或变量名，不需要在前面加模块名 导入模块代码 import packet.mod1 import packet.dir1.mod1 from mod1 import * packet(包) 一个包含一个__init__.py文件的目录,import时会调用一次进行初始化。 __all__ from pack import *并不会导入所有模块，而是会将__all__变量里的模块全部导入，所以我们可以在__init__.py文件中配置__all__变量 __all__ = [\"video\",\"audio\"] __name__ python中的模块就是一个普通文件，不像C++里面有lib、dll的调用。这个文件可能被直接调用，为了判断代码是被模块加载还是直接执行的主模块，可以使用__name__来获取当前模块名称 if __name__ == '__main__' 模块的导入路径 python是如何寻找导入模块的目录呢？ 在python中提供了sys模块，sys.path列表提供了查找模块的路径。如果一个库在多个目录中都有，会按列表的次序来查找。如果我们想自己建一个目录，让python来这个目录查找模块，可以用如下方式 sys.path.insert(0,\"../\") 0表示插入位置，../当前路径的上一层路径。 包的导入 如果我们有一个mypack包，包里面有audio、video和opengl三个模块, # 需要加上包和模块的名称 import mypack.video mypack.video.view() # 引入包的命名空间,不用加包名称 from mypack import audio audio.play() # 引入包和模块的命名空间 from mypack.audio import play play() # 不导入mypack包里的所有模块，只导入__init__.py文件里所有的函数和成员 from mypack import * mypack.opengl.draw() # 调入失败，模块未导入 为了使from mypack import *能导入opengl,__init__.py文件可编写如下 __init__.py __all__ = [\"audio\",\"video\",\"opengl\"] def init(): print(\"mapack init function\") 包里面还可以包含子包，这里不再赘述 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter2/2_10.html":{"url":"chapter2/2_10.html","title":"多进程","keywords":"","body":"python多进程编程 python多进程编程有多种方式 os.fork() linux unix mac 多个进程使用同一段代码(返回0为子进程，非0为父进程) Process() 跨平台 运行多次虚拟机 os.system() © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter3/3_1.html":{"url":"chapter3/3_1.html","title":"ctypes库介绍","keywords":"","body":"ctypes库介绍 Ctypes算是python和C++联合编程中最简单的一种方案，它对环境配置各方面的关联性要求都不高，而且ctypes是独立编程的，与python版本的关联性也不高。 python官网关于ctypes的介绍如下 ctypes is a foreign function library for Python. It provides C compatible data types, and allows calling functions in DLLs or shared libraries. It can be used to wrap these libraries in pure Python. 联合编程应用：与硬件的结合，可能只是调一些底层的接口（访问摄像机），用不了太多的内容，没必要去开发一个扩展库，最简单的方案是编一个动态链接库给python(比如做嵌入式设备，调驱动出现的接口)。还有一些涉及大性能的处理，或者一些算法在C当中实现，然后将接口传到Python 注意：ctypes和Python的交互接口还是相对简单，一些复杂的交互方式还是无法做到，因此算法不能太复杂 本教程均是以windows平台为例编动态库（vs2017），对于linux和Mac平台可自行查阅资料。 windows版本ctypes示例 __declspec(dllexport) 我们在windows中编写一个dll动态链接库来供python调用。window里的动态链接库与linux和Mac有所区别，它需要设置\\_\\_declspec(dllexport)，在linux和Mac中不需要设置，所以在移植到linux中时可以用一个宏来判断当前操作系统。 REF:__declspec(dllexport)与__declspec(dllimport) extern \"C\" python支持的ctypes函数都是C语言的函数， C语言函数不支持重载而C++语言的函数支持重载，对C++来说它存到系统的函数名会将函数的参数加进去，使得C与C++的函数名不一致。所以要在C++函数前面加上extern \"C\"，这样编译器会将函数编译成C的函数。 dll查找目录 dll库在系统目录或当前执行目录，与python库查找路径sys.path无关，sys.path只能影响到python的库和用C++做的扩展库，对dll的查找路径不产生影响。 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-22 "},"chapter3/3_2.html":{"url":"chapter3/3_2.html","title":"python用ctypes调用的windows上C++","keywords":"","body":"python用ctypes调用的windows上C++ 我们在windows上实际演示ctypes的使用 提示：windows中以后缀名来区分文件类型，Linux中文件后缀名对系统无差别 首先在vs2017中创建一个win32控制台应用程序，应用程序设置选择dll和空项目，如下图 创建typesdll.cpp文件，编写代码如下 typesdll.cpp //C++中编译c格式的函数,如果用C语言百衲衣不需要（文件后缀名.c） // __declspec(dllexport) 函数导出到库中 #include extern \"C\" __declspec(dllexport) void TestCtypes() { printf(\"In C TestCtypes\\n\"); } 编译生成testctypes.dll文件,我们再创建一个testctypes.py文件， testctypes.py from ctypes import * # 导入库 windows中dll后缀名不用加 lib = CDLL(\"testctypes\") lib.TestCtypes() 运行上述pyhton程序，会报如下错误 OSError: [WinError 126] 找不到指定的模块。 这里我将dll文件拷贝到和testctypes.py同一目录下，依然报错。将dll拷贝到和python.exe统一目录下时，程序正常运行。使用os.chdir将工作目录更改到当前目录，错误依旧。原因暂时还未找到 注意：生成的dll的位数版本(x86或x64)要与所装python的位数版本一致 Linux 在windows中调用的是dll动态链接库，在Linux中调用.so动态链接库。 在liunx中代码的字符集是utf-8，而在vs中对应的编码是gbk。 我们用宏定义来实现源代码的跨平台,将typesdll.cpp文件改为如下 typesdll.cpp #include // 判断是否是windows WIN32 #ifdef _WIN32 //包含win32和win64 #define XLIB __declspec(dllexport) #else #define XLIB #endif extern \"C\" XLIB void TestCtypes() { printf(\"In C TestCtypes\\n\"); } Reference: 关于win32控制台应用程序、win32项目、mfc项目、空项目 如何在VS2017中创建WIN32控制台程序 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-24 "},"chapter3/3_3.html":{"url":"chapter3/3_3.html","title":"python的ctypes与C语言类型转换","keywords":"","body":"ctypes类型对应 前面我们实现了一个简单的实例，现在我们将之前的示例复杂化一点。 实际情况中我们的函数需要传递参数，接收返回值，这就需要我们能够将python的类型与C语言类型进行相互转换。下表是python官网中提供的类型转换函数。 在python当中不能单独地传一个字符（可以通过对string的下标访问渠道），C中和整形相关的类型全部转成int。 对于c_char和c_wchar分别对应python的1-character bytes object和1-character string，前者存放一个ASCII字符，后者存放一个utf-32。 除了上述基础类型外，我们还可以给ctypes传回调函数、数组、结构体等。 传递数字参数 我们通过c_int和c_float传递float和int,c_int()返回一个类对象，该类的value成员为所传的值 v = c_int(101) print(v.value) 下面的代码中我们在TestCtypesNumber函数中打印该函数的参数，并在python代码中调用 !FILENAME testctypesnumber.cpp #include #ifdef _WIN32 //包含win32和win64 #define XLIB __declspec(dllexport) #else #define XLIB #endif extern \"C\" XLIB void TestCtypesNumber(int x,float y,bool isNum) { printf(\"In C TestCtypesNumber makefile %d %f %d\\n\",x,y,isNum); if (isNum){ printf(\"true\"); } else { printf(\"false\"); } } testctypesnumber.py print(\"Test Ctypes Number\") from ctypes import * lib = CDLL(\"testctypesnumber\") lib.TestCtypesNumber(101, 99.1, True) # 等待用户输入，防止程序直接退出 input() 我们将python的代码和dll放在一个路径下面，在VS中将项目属性——>链接器——>常规——>输出文件设置成和testctypesnumber.cpp同一目录。 为了能在vs中调试dll文件，我们进入到项目属性——>调试——>命令,选择浏览，找到安装的python.exe所在路径，命令参数填写testctypesnumber.py 现在我们在VS中运行代码，发现程序直接退出，说明python代码中发生了异常。为了能显示错误，我们要捕获异常。更改python代码如下 testctypesnumber.py print(\"Test Ctypes Number\") from ctypes import * lib = CDLL(\"testctypesnumber\") try: lib.TestCtypesNumber(101, 99.1, True) except Exception as ex: print(\"TestCtypeNumber error \",ex) # 等待用户输入，防止程序直接退出 input() 再次运行代码，可以看到打印的错误如下 TestCtypeNumber error argument 2: : Don't know how to convert parameter 2 可以看出,int类型可以直接转换(不用调用c_int())，而float类型是不能直接转换的。我们更改一下代码 testctypesnumber.py # ... lib.TestCtypesNumber(101, c_float(99.1), True) # ... 再次运行，程序可以正常输出结果 In C TestCtypesNumber makefile 101 99.099998 1 true 字符串的传递 有两种字符串string和byte，分别用c_wchar_p()和c_char_p()进行传递。 string和byte都是只读类型，在内部不可修改。如果想传一个字符串由C语言进行修改，可以用create_string_buffer创建一个可修改的字符串的缓冲，传给C语言，再由C语言进行写入。 为了让我们的代码在C和C++中均能编译通过,我们定义宏XEXT。定义一个函数TestStringA来测试byte的传递 testctypesstring.cpp #include #ifdef __cplusplus //如果是C++ #define XEXT extern \"C\" #else #define XEXT #endif // __cplusplus #ifdef _WIN32 //包含win32和win64 #define XLIB XEXT __declspec(dllexport) #else #define XLIB XEXT #endif // c_char_p 普通字符 XLIB void TestStringA(const char* str, int size) { printf(\"TestStringA : %s (%d)\\n\", str, size); } 更改我们的python代码如下 testctypes.py print(\"Test Ctypes String\") from ctypes import * try: lib = CDLL(\"testctypesstring\") str1 = \"test string in python\" lib.TestStringA(str1, len(str1)) except Exception as ex: print(\"TestCtypestring error \",ex) # 等待用户输入，防止程序直接退出 input() 在VS中调试执行testctypesstring.cpp代码，发现程序报错并且立刻退出，无法定位程序错误在哪一行。 我们在控制台中执行testctypes.py代码，发现lib.TestStringA(str1, len(str1))这一行代码报错 IndentationError: unindent does not match any outer indentation level 提示是缩进的错误！然而代码明明是对齐的。这里有一个技巧，在Notepad++中可以显示出所有字符： 视图—>显示符号—>显示空格与制表符。发现是空格和Tab键混用了。 将缩进全部改用Tab后，再次在命令行中运行程序,发现传给TestStringA函数的是string类型而非byte 将testctypes.py第5行代码改为str1 = b\"test string in python\"进行转换，程序正常执行。 上面测试的是普通字符，为了测试宽字符，我们在testctypesstring.cpp中再添加函数TestStringW // c_wchar_p 宽字符 XLIB void TestStringW(const wchar_t* str, int size) { //宽字符前要加L进行转换 wprintf(L\"TestStringW : %s (%d)\\n\", str, size); } 在testctypes.py中增加下面代码 !FILENAME testctypes.py # try语句块里 wstr = \"wide string in python\" lib.TestStringW(wstr,len(wstr)) 运行程序，输出如下 Test Ctypes String TestStringA : test string in python (21) TestStringW : wide string in python (21) 普通字符与宽字符均不需要显示转换 Python传给C的字符串在C中是可以修改的，但是建议不要这么做，这会造成语法的不一致(应为string类型在python中不可更改)。 如果我们需要修改，可以通过create_string_buffer()函数。 buf = create_string_buffer(100) 我们在testctypesstring.cpp中再添加函数TestStringBuffer // 传递可修改的buf XLIB void TestStringBuffer(char* str, int size) { str[0] = '@'; str[1] = '#'; str[2] = '\\0';//字符串结束标识 printf(\"TestStringBuffer : %s (%d)\\n\", str, size); } 在testctypes.py中增添如下代码 !FILENAME testctypes.py # try语句块里 buf = create_string_buffer(10) lib.TestStringBuffer(buf) print(\"in python buf = \",buf.raw, buf.value, len(buf), sep = '\\n') 运行代码结果如下 TestStringBuffer : @# (1447823194) in python buf = b'@#\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' b'@#' 10 如有有些字符串需要在C中算完了再传给python，可以使用`create_string_buffer` © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-06-04 "},"chapter3/3_4.html":{"url":"chapter3/3_4.html","title":"跨平台调用C语言库函数","keywords":"","body":"在各个平台上用python来调用C语言库（C语言内置的一些函数）的方式不一样。 Windows调用：libc = cdll.msvcrt Linux调用: libc = CDLL(\"libc.so.6\") Mac调用：libc = CDLL(\"libc.dylib\") 使用C的printf函数： libc.printf(b \"hello world\") Python判断操作系统 不需要为每个系统写一套代码，可以通过python来直接判断平台。 先用import platform导入模块，然后调用platform.system()可以返回系统的名称 （分别是Darwin Linux Windows ）。 python跨平台调用C语言库 testclib.py print(\"Test C Lib\") from ctypes import * from platform import system sys = system() if sys == \"Windows\": libc = cdll.msvcrt elif sys == \"Linux\": libc = CDLL(\"libc.so.6\") elif sys == \"Darwin\": libc = CDLL(\"libc.dylib\") else: printf(\"unknow system\") libc.printf(b\"Python string %s %d\", b\"str001\", 1001) 调用windows系统函数 我们来使用ctypes调用win32的MessageBox testwinapi.py print(\"Test Win API\") from ctypes import * re = windll.user32.MessageBoxA(0, \"窗口内容\".encode(\"gbk\"),\"请选择\".encode(\"gbk\"), 1) if re == 1: windll.user32.MessageBoxW(0, \"点击了确认按钮\",\"已选择\", 0) else: windll.user32.MessageBoxW(0, \"点击了取消按钮\",\"已选择\", 0) 运行程序可正常弹出对话框 注意：在win32当中调函数可以直接调用`MessageBox`,不用区分`MessageBoxA`和`MessageBoxW`，因为`MessageBox`其实是一个宏，它根据当前编码的字符集来决定调用`MessageBoxA`还是`MessageBoxW`，而这个宏在python中肯定是访问，所以需要明确指明调用`MessageBoxA`还是`MessageBoxW` © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-25 "},"chapter3/3_5.html":{"url":"chapter3/3_5.html","title":"Ctypes获取返回值","keywords":"","body":"前面我们涉及了参数传递的几种类型，但是还没有获取函数的返回值。 我们通过ctypes来调用C语言的函数，取得它返回值。 在取得返回值时，我们要考虑返回值的空间要在哪边，假如是返回了一个指针，要考虑到指针的空间在哪里释放。 假如我们在C当中申请了一块空间，而我们在python当中没法释放它，就会出问题。 Ctypes获取返回值 默认返回值都是int(就算函数返回设定的是void) lib.CFunction.restype = c_char_p 我们在testctypesreturn.cpp中编写返回int、char*和wchar_t的函数 testctypesreturn.cpp #include #ifdef __cplusplus //如果是C++ #define XEXT extern \"C\" #else #define XEXT #endif // __cplusplus #ifdef _WIN32 //包含win32和win64 #define XLIB XEXT __declspec(dllexport) #else #define XLIB XEXT #endif XLIB int TestReturnInt() { return 101; } XLIB const char* TestReturnChar() { return \"TestReturnChar String\"; } XLIB const wchar_t* TestReturnWChar() { return L\"TestReturnWChar String\"; } testctypes.py代码如下 testctypes.py print(\"Test Ctypes Return\") from ctypes import * try: lib = CDLL(\"testctypesreturn\") # 设定返回值类型 # int 是默认值 print(\"TestReturnInt = \", lib.TestReturnInt()) lib.TestReturnChar.restype = c_char_p # 除int外，都要指定返回类型 re = lib.TestReturnChar() print(type(re)) # 返回的直接是bytes print(\"TestReturnChar = \", lib.TestReturnChar()) lib.TestReturnWChar.restype = c_wchar_p re = lib.TestReturnWChar() print(type(re)) # 返回的直接是string print(\"TestReturnWChar = \", lib.TestReturnWChar()) except Exception as ex: print(\"TestCtypestring error \",ex) # 等待用户输入，防止程序直接退出 input() 运行结果如下 Test Ctypes Return TestReturnInt = 101 TestReturnChar = b'TestReturnChar String' TestReturnWChar = TestReturnWChar String Ctypes传递和返回指针 ctypes传递指针的方式如下 lib.Function.argtypes = (POINTER(c_float),) lib.Function.restype = (POINTER(c_void_p),) 其中括号内的参数可以指定多个，它其实是一个元组（所以要加逗号）。 POINTER()返回一个类型 pointer()返回实例 byref(x[,offset]) 获取指针 下面的例子，通过传递一个指针参数，在C语言当中来改变这个值，然后再在Python当中打印。 python没有提供接口来对返回的指针进行修改(但实际测试是可以更改的)，我们可以返回结构体指针来传给下一个参数。 我们创建一个testctypespointer.cpp文件(之后的代码省略相关跨平台的宏定义)， testctypespointer.cpp XLIB int* TestPointer(float *f1) { static int re = 1001; *f1 = 99.9f; printf(\"In C++ TestPointer re = %d\\n\", re); return &re; } 修改之前的testctypes.py代码,如下 testctypes.py print(\"Test Ctypes Pointer\") from ctypes import * try: lib = CDLL(\"testctypespointer\") # 参数类型 要传递元组 lib.TestPointer.argtypes = (POINTER(c_float),) lib.TestPointer.restype = POINTER(c_int) f1 = c_float(88.8) print(\"begin f1 = \",f1) # byref返回指针 re = lib.TestPointer(byref(f1)) print(\"end f1 = \",f1) print(\"return = \",re) print(\"return type = \",type(re)) # re.contents 就是指针指向的内容 re.contents.value = 666 print(\"In Python TestPointer re =\", re.contents.value) # 在C语言中再调用一次 lib.TestPointer(byref(f1)) except Exception as ex: print(\"TestCtypestring error \",ex) # 等待用户输入，防止程序直接退出 input() 运行的结果如下 Test Ctypes Pointer begin f1 = c_float(88.80000305175781) In C++ TestPointer re = 1001 end f1 = c_float(99.9000015258789) return = return type = In Python TestPointer re = 666 In C++ TestPointer re = 666 从结果可以看出，python中的f1在C中被修改，C中返回的`re`变量在python中也能被修改 CTypes传递数组 通过CType来给C语言传递一个数组（python的list）。 CTypes要返回一个数组还存在一些问题，通过CTypes返回一个数组，那么这个数组的空间由谁来管理？ 返回给Python，空间由谁来释放？ 一般如果想用CTypes从C来返回一个数组给Python，可以通过指针的方式来传递。 因为传递数组涉及到效率问题，就算传给python，也可能涉及到复制的问题。 python内部的数组传递只是把引用计数加1，而如果C语言的数组过来，肯定是要复制的，所以开销非常大，一般也是通过指针的方式。 传递数组语法如下 (c_int*10)(1,2,3,4,5,6,7,8,9,10) Ctypes数组是固定长度的，需要指定长度。 一般CTypes传递数组的方式如下 a = [1,2,3,4,5,6,7,8,9.10] (c_int*10)(*a) 或则 TenArr = c_int*10 # TenArr是一个类型 a = TenArr(*a) 下面测试通过CTypes像C传递数组 编写C函数如下 XLIB void TestArray(int *arr, int size) { printf(\"=========In C++ ===============\\n\"); for (int i = 0; i testctypes.py print(\"Test Ctypes Array\") from ctypes import * try: lib = CDLL(\"testctypesarray\") # 传递一个参数类型 c_int*10 arr = [1,2,3,4,5,6,7,8,9,10] TenArrType = c_int*len(arr) # *把list中每个元素当作位置参数等同于 TenArrType(1,2,3,4,5,...) carr = TenArrType(*arr) lib.TestArray.argtypes = (TenArrType,) lib.TestArray(carr,len(arr)) except Exception as ex: print(\"testctyeps error\",ex) # 等待用户输入，程序不退出 input() 运行结果如下 Test Ctypes Array =========In C++ =============== 1 2 3 4 5 6 7 8 9 10 CTypes传递和返回结构体 CTypes给C函数传递结构体对象指针和数组 结构体之间存在格式转化的问题。涉及到内存对齐和普通的字节大小问题。 对于复杂的应用建议做扩展包自己定义结构体。 在python当中定义一个类，统一继承一个Structure类型。它是专门为结构体做参数传递的。 它里面有一个固定的成员_fields_，一系列结构体元素都在里面定义。_fields_是一个list，list里面的元素是一个元组，用来定义结构体成员。 class Pos(Structure): _fields_ = [(\"x\",c_int),(\"y\",c_int)] 我们通过代码来演示 编写C函数如下 struct Pos { int x; int y; }; XLIB void TestStruct(Pos pos) { printf(\"\\nIn c++ TestStruct \\n\"); printf(\"pos x = %d,y = %d\\n\",pos.x, pos.y); } python代码如下 print(\"Test Ctypes struct\") from ctypes import * class Pos(Structure): _fields_ = [(\"x\",c_int),(\"y\",c_int)] try: lib = CDLL(\"testctypesstruct\") pos1 = Pos(11,22) lib.TestStruct.argtypes = (Pos,) lib.TestStruct(pos1) except Exception as ex: print(\"testctyeps error\",ex) # 等待用户输入，程序不退出 input() 运行结果如下，可以看到python的结构体成功传给了C Test Ctypes struct In c++ TestStruct pos x = 11,y = 22 定义结构体的目的有时候是为了调用已有的函数，而已有函数的参数可能为结构体指针。 下面我们改进代码，来通过python像C来传递指针。改进的C函数如下 XLIB void TestStruct(Pos pos1, Pos* pos2) { printf(\"\\nIn c++ TestStruct \\n\"); printf(\"pos1 x = %d,y = %d\\n\",pos1.x, pos1.y); printf(\"pos2 x = %d,y = %d\\n\", pos2->x, pos2->y); } python代码更改如下 print(\"Test Ctypes struct\") from ctypes import * class Pos(Structure): _fields_ = [(\"x\",c_int),(\"y\",c_int)] try: lib = CDLL(\"testctypesstruct\") pos1 = Pos(11,22) lib.TestStruct.argtypes = (Pos,POINTER(pos)) pos2 = Pos(33,44) lib.TestStruct(pos1,byref(pos2)) except Exception as ex: print(\"testctyeps error\",ex) # 等待用户输入，程序不退出 input() 运行结果如下 Test Ctypes struct In c++ TestStruct pos1 x = 11,y = 22 pos2 x = 33,y = 44 除了传递结构体对象和结构体指针之外，我们再来传递结构体数组 更改C函数 XLIB void TestStruct(Pos pos1, Pos* pos2,Pos *pos3,int size) { printf(\"\\nIn c++ TestStruct \\n\"); printf(\"pos1 x = %d,y = %d\\n\",pos1.x, pos1.y); printf(\"pos2 x = %d,y = %d\\n\", pos2->x, pos2->y); printf(\"pos3 =\"); for (int i = 0; i 更改python代码 print(\"Test Ctypes struct\") from ctypes import * class Pos(Structure): _fields_ = [(\"x\",c_int),(\"y\",c_int)] try: lib = CDLL(\"testctypesstruct\") pos1 = Pos(11,22) lib.TestStruct.argtypes = (Pos,POINTER(Pos)) pos2 = Pos(33,44) #传递结构体数组 pos3 = [Pos(1,1),Pos(2,2),Pos(3,3)] PosType = Pos*len(pos3) lib.TestStruct(pos1,byref(pos2),PosType(*pos3),len(pos3)) except Exception as ex: print(\"testctyeps error\",ex) # 等待用户输入，程序不退出 input() 运行结果如下 Test Ctypes struct In c++ TestStruct pos1 x = 11,y = 22 pos2 x = 33,y = 44 pos3 =(1,1)(2,2)(3,3) 注意Python代码第行，我们没有显示指定参数类型，代码还是可以正常运行。 若要显示指定，如下： lib.TestStruct.argtypes = (Pos,POINTER(Pos),PosType,c_int) CTypes获取C函数返回结构体对象和指针 下面的代码展示通过CTypes从C获取结构体对象和指针 C函数如下 XLIB Pos GetPos() { Pos pos; pos.x = 101; pos.y = 102; return pos; } XLIB Pos* TestStruct(Pos pos1, Pos* pos2,Pos *pos3,int size) { printf(\"\\nIn c++ TestStruct \\n\"); printf(\"pos1 x = %d,y = %d\\n\",pos1.x, pos1.y); printf(\"pos2 x = %d,y = %d\\n\", pos2->x, pos2->y); printf(\"pos3 =\"); for (int i = 0; i python代码如下 print(\"Test Ctypes struct\") from ctypes import * class Pos(Structure): _fields_ = [(\"x\",c_int),(\"y\",c_int)] try: lib = CDLL(\"testctypesstruct\") pos1 = Pos(11,22) pos2 = Pos(33,44) pos3 = [Pos(1,1),Pos(2,2),Pos(3,3)] PosType = Pos*len(pos3) # 返回结构体指针 lib.TestStruct.restype = POINTER(Pos); repos = lib.TestStruct(pos1,byref(pos2),PosType(*pos3),len(pos3)) print(repos) print(type(repos)) print(repos.contents.x, repos.contents.y) # 返回结构体对象 lib.GetPos.restype = Pos repos2 = lib.GetPos() print(\"GetPos = \",repos2.x, repos2.y) except Exception as ex: print(\"testctyeps error\",ex) # 等待用户输入，程序不退出 input() 运行结果如下 Test Ctypes struct In c++ TestStruct pos1 x = 11,y = 22 pos2 x = 33,y = 44 pos3 =(1,1)(2,2)(3,3) 88 99 GetPos = 101 102 注意：返回指针需要定义静态变量，因为指针指向的是局部变量的地址，而局部变量在函数执行完后就被销毁，导致指针指向一个无效的地址。但是返回结构体对象，会先对该对象进行拷贝，所以可以直接返回。 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-05-29 "},"chapter3/3_6.html":{"url":"chapter3/3_6.html","title":"Ctypes传递回调函数","keywords":"","body":"通过Ctypes来给C语言传递回调函数 C语言中有些函数需要制定一些回调函数，在调用函数时需要传递函数指针过去。 函数指针类型创建的方法如下 CFUNCTYPE(返回值类型，参数类型...) 下面是一个示例 CMPFUNC = CFUNCTYPE(c_int,c_int,POINTER(c_int)) def py_cmp_func(a,b): print(\"py_cmp_func\",a,b) return 0 cmp_func = CMPFUNC(py_cmp_func) 我们通过ctypes传递回调函数给C库函数qsort进行快速排序(windows平台) void qsort(void base, size_t nitems,size_t size, int(compar)(const void,const void)) testctypesqsort.py print(\"Test Ctypees qsort function callback\") from ctypes import * lib = cdll.msvcrt # 快速排序比较函数 CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int),POINTER(c_int)) # 比较函数判断大小 def cmp_callback(a, b): # a 指向c_int return a.contents.value - b.contents.value cmpfunc = CMPFUNC(cmp_callback) qsort = lib.qsort # 排序的数据 整型列表 data = (c_int * 5)(5, 1, 7, 33, 99) for i in data: print(i ,end = \" \") print(\"\\n开始排序\") qsort(data, len(data), sizeof(c_int), cmpfunc) for i in data: print(i ,end = \" \") 运行结果如下 Test Ctypees qsort function callback 5 1 7 33 99 开始排序 1 5 7 33 99 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-06-01 "},"chapter3/3_7.html":{"url":"chapter3/3_7.html","title":"在c函数中调用Python函数s","keywords":"","body":"通过ctypes在C函数中调用python函数 在C语言中定义如下函数 //定义函数指针类型 typedef void(*Callback)(int a); XLIB void TestCallback(int *arr, int size, Callback call) { for (int i = 0; i python代码如下 !FILENAME testctypes.py print(\"Test CTypesfunction\") from ctypes import * #回调函数类型 返回值void 参数c_int FUNT = CFUNCTYPE(None, c_int) #回调函数 def callback(a): print(\"Py a = \",a) try: lib = CDLL(\"Testctypesfunction\") # 传递的数据 arr = [1, 3, 55, 11, 34] ArrType = c_int * len(arr) # Ctype的数组对象 carr = ArrType(*arr) lib.TestCallback.argtypes = (ArrType, c_int, FUNT) lib.TestCallback(carr,len(arr),FUNT(callback)) except Exception as ex: print(\"testctyeps error\",ex) # 等待用户输入，程序不退出 input() 运行结果如下 Test CTypesfunction Py a = 1 Py a = 3 Py a = 55 Py a = 11 Py a = 34 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-06-01 "},"chapter4/4_1.html":{"url":"chapter4/4_1.html","title":"Python源码编译和安装","keywords":"","body":"我们前面用CTypes来调用python的时候，没有关注到Python的源码， 我们是通过生成动态链接库用API来直接访问内部的函数，这种方式灵活性很强。 但是如果我们要深入Python内部，包括做多线程处理的时候，就很难做了。 因为我们并没有调用Python的接口，并没有和python的虚拟机结合起来， 所以一些更深入的需求，就需要我们自己做扩展模块。 做扩展模块涉及到的问题是要调Python的源码，调用python源码直接用已安装好的也没有问题， 但是我们要调试跟进，这时候我们就要把python的源码编译一下，生成它的调试信息， 而且还要根据它的不同版本进行编译。 注意：扩展库一定要跟版本完全一致，它和`Ctypes`的引用方式不太一样。ctypes通过接口访问dll，而扩展库是将程序直接嵌入进去，会调用它自己的接口，而不同版本的接口地址是不一样的 总之，做扩展库的第一步是将python的整个源码进行编译，编译完之后生成exe文件 python编译windows环境准备 先在python官网下载python源码，在Linux里面我们用gcc或clang，在windows中使用vs编译。vs2015中包含win10SDK, python依赖工具和库 nuget python运行环境 其他依赖库源码 sqlite openssl zips ... Python源码路径 PCbuild项目路径(windows) 存放基于vs的项目文件和解决方案文件 PCbuild/win32 编译输出 externals 依赖工具和库 Lib\\site-packages扩展库安装路径 完成python源码在windows中编译 © liangqi all right reserved，powered by Gitbook文件修订时间： 2019-06-03 "},"chapter5/5_1.html":{"url":"chapter5/5_1.html","title":"Python的C扩展库模块入口创建","keywords":"","body":"© liangqi all right reserved，powered by Gitbook文件修订时间： 2019-06-03 "}}